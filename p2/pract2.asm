;**************************************************************************
; SBM 2019
; PRACTICA 2
; AUTORES: David Cabornero Pascual y Sergio Galán Martín
;**************************************************************************
; DEFINICION DEL SEGMENTO DE DATOS
DATOS SEGMENT
CLR_PANT DB 1BH, "[2", "J$"
MATRIZ DB 9, 8, 7, 6, 5, 4, 3, 2, -4 
RESULT DW 0
ACCESOS DW 0, 4, 8, 3, 7, 2, 1, 5, 6, 2, 4, 6, 3, 1, 8, 0, 7, 5
SIGNO DB ?
TAB DB 9, '$'
SLASH DB 7CH, '$'
NEWLINE DB 0AH, '$'
SPACE DB " $"
DETA DB "   |A|= |$"
EQB DB "| = $"
DECIMN DB 2 dup(?)
ASCIIN DB 4 dup(?)
DATOS ENDS
;**************************************************************************
; DEFINICION DEL SEGMENTO DE PILA
PILA SEGMENT STACK "STACK"
DB 40H DUP (0) ;ejemplo de inicialización, 64 bytes inicializados a 0
PILA ENDS
;**************************************************************************
; DEFINICION DEL SEGMENTO EXTRA
EXTRA SEGMENT
EXTRA ENDS
;**************************************************************************
; DEFINICION DEL SEGMENTO DE CODIGO
CODE SEGMENT
ASSUME CS: CODE, DS: DATOS, ES: EXTRA, SS: PILA
; COMIENZO DEL PROCEDIMIENTO PRINCIPAL
INICIO PROC
; INICIALIZA LOS REGISTROS DE SEGMENTO CON SU VALOR
MOV AX, DATOS
MOV DS, AX
MOV AX, PILA
MOV SS, AX
MOV AX, EXTRA
MOV ES, AX
MOV SP, 64 ; CARGA EL PUNTERO DE PILA CON EL VALOR MAS ALTO
; FIN DE LAS INICIALIZACIONES
; COMIENZO DEL PROGRAMA
MOV BX, 0
CALL DIAG
ADD RESULT, AX
ADD BX, 6
CALL DIAG
ADD RESULT, AX
ADD BX, 6
CALL DIAG
ADD RESULT, AX
ADD BX, 6
CALL DIAG
SUB RESULT, AX
ADD BX, 6
CALL DIAG
SUB RESULT, AX
ADD BX, 6
CALL DIAG
SUB RESULT, AX

CALL OUTPUT


; FIN DEL PROGRAMA
MOV AX, 4C00H
INT 21H
INICIO ENDP

DIAG PROC FAR
MOV SI, ACCESOS[BX]
MOV AL, MATRIZ[SI]
MOV SI, ACCESOS[BX+2]
MOV DL, MATRIZ[SI]
IMUL DL
MOV SI, ACCESOS[BX+4]
MOV DL, MATRIZ[SI]
MOV DH, 0
IMUL DX
RET
DIAG ENDP

OUTPUT PROC FAR
MOV BX, 0
MOV AH, 9 ; BORRA LA PANTALLA
MOV DX, OFFSET CLR_PANT
INT 21H

MOV DX, OFFSET TAB
INT 21H

MOV DX, OFFSET SLASH
INT 21H

CALL PRINTNUM
INC BX
MOV DX, OFFSET SPACE
INT 21H
CALL PRINTNUM
INC BX
MOV DX, OFFSET SPACE
INT 21H
CALL PRINTNUM
INC BX


;MOV AH, 9
MOV DX, OFFSET SLASH
INT 21H

MOV DX, OFFSET NEWLINE
INT 21H

MOV DX, OFFSET DETA
INT 21H

CALL PRINTNUM
INC BX
MOV DX, OFFSET SPACE
INT 21H
CALL PRINTNUM
MOV DX, OFFSET SPACE
INT 21H
INC BX
CALL PRINTNUM
INC BX

;MOV AH, 9
MOV DX, OFFSET EQB
INT 21H

CALL PRINTRES

MOV DX, OFFSET NEWLINE
INT 21H

MOV DX, OFFSET TAB
INT 21H

MOV DX, OFFSET SLASH
INT 21H

CALL PRINTNUM
INC BX
MOV DX, OFFSET SPACE
INT 21H
CALL PRINTNUM
INC BX
MOV DX, OFFSET SPACE
INT 21H
CALL PRINTNUM
INC BX

;MOV AH, 9
MOV DX, OFFSET SLASH
INT 21H

RET
OUTPUT ENDP

CONVERTN PROC FAR
MOV SI, 0
MOV AL, MATRIZ[BX]
MOV CL, 0AH
DIVID:
MOV AH, 0H
DIV CL
MOV DECIMN[SI], AH ; GUARDAMOS EN DECIMN EL RESTO DE LA DIVISIÓN 
INC SI ; INCREMENTAMOS LA POSICIÓN EN LA QUE GUARDAREMOS LA SIGUIENTE POSIBLE CIFRA
ADD AL, 0
JNZ DIVID ; SI EL COCIENTE NO ES CERO, SEGUIMOS DIVIDIENDO
RET
CONVERTN ENDP

CONVERTASC PROC FAR
MOV DI, 1
BUCLE: DEC SI
JS FINISH
MOV AL, DECIMN[SI]
ADD AL, 30H
MOV ASCIIN[DI], AL
INC DI
JMP BUCLE 
FINISH:
MOV AH, SIGNO
MOV ASCIIN, AH 
MOV ASCIIN[DI], '$'
RET
CONVERTASC ENDP

PRINTNUM PROC FAR
ADD MATRIZ[BX], 0
JNS POSITIVO
MOV SIGNO, '-'
NEG MATRIZ[BX] ; HACEMOS QUE EL NÚMERO GUARDADO EN MATRIZ SEA POSITIVO
JMP CONT
POSITIVO: MOV SIGNO, '+'
CONT: 
CALL CONVERTN
CALL CONVERTASC
MOV AH, 9
MOV DX, OFFSET ASCIIN ; IMPRIMIMOS EL NÚMERO
INT 21H
RET
PRINTNUM ENDP

PRINTRES PROC FAR
ADD RESULT, 0
JNS POSITIVO1
MOV SIGNO, '-'
NEG RESULT
JMP CONT1
POSITIVO1: MOV SIGNO, '+'
CONT1:
CALL CONVERTRES
CALL CONVERTASC
MOV DX, OFFSET ASCIIN ; IMPRIMIMOS EL NÚMERO
INT 21H
RET 
PRINTRES ENDP

CONVERTRES PROC FAR
MOV SI, 0
MOV AX, RESULT
MOV CX, 0AH
DIVID1:
DIV CX
MOV DECIMN[SI], DL ; GUARDAMOS EN DECIMN EL RESTO DE LA DIVISIÓN 
INC SI ; INCREMENTAMOS LA POSICIÓN EN LA QUE GUARDAREMOS LA SIGUIENTE POSIBLE CIFRA
ADD AX, 0
JNZ DIVID1 ; SI EL COCIENTE NO ES CERO, SEGUIMOS DIVIDIENDO
RET
CONVERTRES ENDP

; FIN DEL SEGMENTO DE CODIGO
CODE ENDS
; FIN DEL PROGRAMA INDICANDO DONDE COMIENZA LA EJECUCION
END INICIO 
