;**************************************************************************
; SBM 2019
; PRACTICA 2
; AUTORES: David Cabornero Pascual y Sergio Galán Martín
;**************************************************************************
; DEFINICION DEL SEGMENTO DE DATOS
DATOS SEGMENT
;DATOS INICIALES
	MATRIZ DB 9 dup(?)
	ACCESOS DW 0, 4, 8, 3, 7, 2, 1, 5, 6, 2, 4, 6, 3, 1, 8, 0, 7, 5 ; SON PALABRAS PARA PODER USAR SI COMO INDICE
	MATRIZASC DB 50 dup(?)
;VARIABLES AUXILIARES Y RESULTADO
	RESULT DW 0
	SIGNO DB ?
	DECIMN DB 5 dup(?)
	ASCIIN DB 5 dup(?)
	ERRFLAG DB 0
;CARACTERES PARA IMPRIMIR
	CLR_PANT DB 1BH, "[2", "J$"
	PEDIR DB "Introduce los valores de la matriz separados por coma y espacio, con signo (Ejemplo: +1, -2, +7, -4, +3, +3, -5, -5, +2): $"
	ERRSTRING DB "ERROR: Los numeros deben estar comprendidos entre -16 y 15$"
	TAB DB 9, '$'
	SLASH DB 7CH, '$'
	NEWLINE DB 0AH, '$'
	SPACE DB " $"
	DETA DB "   |A|= |$"
	EQB DB "| = $"
	DATOS ENDS
;**************************************************************************
; DEFINICION DEL SEGMENTO DE PILA
PILA SEGMENT STACK "STACK"
	DB 40H DUP (0) ;ejemplo de inicialización, 64 bytes inicializados a 0
PILA ENDS
;**************************************************************************
; DEFINICION DEL SEGMENTO EXTRA
EXTRA SEGMENT
EXTRA ENDS
;**************************************************************************
; DEFINICION DEL SEGMENTO DE CODIGO
CODE SEGMENT
ASSUME CS: CODE, DS: DATOS, ES: EXTRA, SS: PILA
; COMIENZO DEL PROCEDIMIENTO PRINCIPAL
INICIO PROC
; DEFINIMOS MACROS
	NL EQU 0DH		;SE USA PARA COMPROBAR SI EL USUARIO HA TERMINADO
	LIMSUP EQU 15	;MAXIMO NUMERO PERMITIDO DENTRO DEL DETERMINANTE
	LIMINF EQU -16	;MINIMO NUMERO PERMITIDO DENTRO DEL DETERMINANTE
	MAXMATR EQU 40	;MAXIMO NUMERO DE CARACTERES ADMITIDO
	WRITE EQU 9		;CONSTANTE A LA QUE DEBE ESTAR AH PARA ESCRIBIR EN PANTALLA
	READ EQU 0AH	;CONSTANTE A LA QUE DEBE ESTAR AH PARA LEER DE PANTALLA
	NUMSMATR EQU 9	;CANTIDAD DE NUMEROS QUE HAY QUE LEER DE PANTALLA
	TOASC EQU 30H	;CANTIDAD A SUMAR A UN NUMERO PARA QUE PASE DE DECIMAL A ESE MISMO NUMERO EN ASCII
; INICIALIZA LOS REGISTROS DE SEGMENTO CON SU VALOR
	MOV AX, DATOS
	MOV DS, AX
	MOV AX, PILA
	MOV SS, AX
	MOV AX, EXTRA
	MOV ES, AX
	MOV SP, 64 ; CARGA EL PUNTERO DE PILA CON EL VALOR MAS ALTO
; FIN DE LAS INICIALIZACIONES
; COMIENZO DEL PROGRAMA
; PEDIMOS LA MATRIZ AL USUARIO
START:
	MOV AH, WRITE
	MOV DX, OFFSET NEWLINE
	INT 21H
	MOV DX, OFFSET PEDIR
	INT 21H
; LEEMOS LO TECLEADO EN MEMORIA
	MOV AH, READ
	MOV DX, OFFSET MATRIZASC
	MOV MATRIZASC[0], MAXMATR ; MÁXIMO NÚMERO DE CARACTERES
	INT 21H
	
; INICIALIZAMOS LOS REGISTROS ADECUADAMENTE PARA PARSEAR
	MOV SI, 0
	MOV BX, 2 ; HAY DOS CARACTERES "INÚTILES" AL PRINCIPIO DE LA STRING LEÍDA

BUCLELECT: ; PARSEAMOS LOS DIGITOS DE LA MATRIZ
	CALL ASCTON
	CMP ERRFLAG, 1
	JE ERRHAND ; SI HAY OVERFLOW O SI EL NÚMERO ESTÁ FUERA DEL RANGO ADMITIDO
	ADD BX, 2 ; AVANZAMOS DOS PARA SALTARNOS EL ESPACIO
	INC SI ; AVANZAMOS EL ÍNDICE DONDE GUARDAMOS EL SIGUIENTE NÚMERO DE LA MATRIZ
	CMP SI, NUMSMATR ; COMPROBAMOS SI YA TENEMOS TODOS LOS NÚMEROS DE LA MATRIZ
	JNE BUCLELECT

; CALCULAMOS EL DETERMINANTE
	MOV BX, 0
	CALL DIAG
	ADD RESULT, AX
	ADD BX, 6
	CALL DIAG
	ADD RESULT, AX
	ADD BX, 6
	CALL DIAG
	ADD RESULT, AX
	ADD BX, 6
	CALL DIAG
	SUB RESULT, AX
	ADD BX, 6
	CALL DIAG
	SUB RESULT, AX
	ADD BX, 6
	CALL DIAG
	SUB RESULT, AX

;LLAMAMOS A UNA RUTINA QUE SE ENCARGARÁ DE IMPRIMIR TODO POR PANTALLA
	CALL OUTPUT
	JMP ENDPROG
ERRHAND: ; SI HAY OVERFLOW PARSEANDO UN NÚMERO O EL NÚMERO ES MENOR QUE -16 O MAYOR QUE 15
	MOV ERRFLAG, 0
	MOV AH, WRITE
	MOV DX, OFFSET NEWLINE
	INT 21H
	MOV DX, OFFSET ERRSTRING
	INT 21H
	JMP START ; VOLVEMOS A EMPEZAR
ENDPROG:
; FIN DEL PROGRAMA
	MOV AX, 4C00H
	INT 21H
INICIO ENDP

DIAG PROC FAR ;GUARDA EN AX LA DIAGONAL CALCULADA
	MOV SI, ACCESOS[BX]
	MOV AL, MATRIZ[SI]
	MOV SI, ACCESOS[BX+2]
	MOV DL, MATRIZ[SI]
	IMUL DL
	MOV SI, ACCESOS[BX+4]
	MOV DL, MATRIZ[SI]
	ADD DL, 0
	JS NEGATIVO ; SI EL NÚMERO ES NEGATIVO
	MOV DH, 0
	JMP FINAL
NEGATIVO: 
	MOV DH, -1 ; EXTENDEMOS EL SIGNO
FINAL: 
	IMUL DX
	RET
DIAG ENDP



OUTPUT PROC FAR ; IMPRIME POR PANTALLA LA SALIDA DESEADA
	MOV BX, 0
	MOV AH, WRITE ; BORRA LA PANTALLA
	MOV DX, OFFSET CLR_PANT
	INT 21H

	MOV DX, OFFSET TAB ;IMPRIME LOS TABULADORES
	INT 21H

	MOV DX, OFFSET SLASH ;COMIENZA LA PRIMERA FILA DEL DETERMINANTE
	INT 21H

	CALL PRINTNUM ;IMPRIME LOS TRES PRIMEROS NUMEROS DEL DETERMINANTE
	INC BX
	MOV DX, OFFSET SPACE
	INT 21H
	CALL PRINTNUM
	INC BX
	MOV DX, OFFSET SPACE
	INT 21H
	CALL PRINTNUM
	INC BX


	MOV DX, OFFSET SLASH ;CIERRA LA PRIMERA FILA DEL DETERMINANTE
	INT 21H

	MOV DX, OFFSET NEWLINE ;SALTO DE LINEA
	INT 21H

	MOV DX, OFFSET DETA ; |A| = |
	INT 21H

	CALL PRINTNUM ;ESCRIBE LA SEGUNDA FILA DEL DETERMINANTE
	INC BX
	MOV DX, OFFSET SPACE
	INT 21H
	CALL PRINTNUM
	MOV DX, OFFSET SPACE
	INT 21H
	INC BX
	CALL PRINTNUM
	INC BX


	MOV DX, OFFSET EQB ;CIERRA LA SEGUNDA FILA E IMPRIME UN IGUAL
	INT 21H

	CALL PRINTRES ;IMPRIME EL RESULTADO

	MOV DX, OFFSET NEWLINE ;SALTO DE LINEA
	INT 21H

	MOV DX, OFFSET TAB ;IMPRIME LOS TABULADORES
	INT 21H

	MOV DX, OFFSET SLASH ;COMIENZA LA TERCERA FILA DEL DETERMINANTE
	INT 21H

	CALL PRINTNUM ;IMPRIME LA TERCERA FILA DEL DETERMINANTE	
	INC BX
	MOV DX, OFFSET SPACE
	INT 21H
	CALL PRINTNUM
	INC BX
	MOV DX, OFFSET SPACE
	INT 21H
	CALL PRINTNUM
	INC BX

	MOV DX, OFFSET SLASH ;CIERRA LA TERCERA FILA DEL DETERMINANTE
	INT 21H

	RET
OUTPUT ENDP

CONVERTN PROC FAR ;SE COLOCA CADA DIGITO DECIMAL DEL NUMERO EN UNA POSICION DISTINTA
	MOV SI, 0
	MOV AL, MATRIZ[BX]
	MOV CL, 10 ; TENEMOS QUE DIVIDIR POR 10
DIVID:
	MOV AH, 0
	DIV CL
	MOV DECIMN[SI], AH ; GUARDAMOS EN DECIMN EL RESTO DE LA DIVISIÓN 
	INC SI ; INCREMENTAMOS LA POSICIÓN EN LA QUE GUARDAREMOS LA SIGUIENTE POSIBLE CIFRA
	ADD AL, 0
	JNZ DIVID ; SI EL COCIENTE NO ES CERO, SEGUIMOS DIVIDIENDO
	RET
CONVERTN ENDP

CONVERTASC PROC FAR ;CONVIERTE LOS NUMEROS SEPARADOS EN ASCII PARA IMPRIMIRLOS
	MOV DI, 1
BUCLE: 
	DEC SI ;SUMAMOS 30 A LOS NUMEROS PARA QUE COINCIDAN CON SU CODIGO ASCII
	JS FINISH
	MOV AL, DECIMN[SI]
	ADD AL, TOASC
	MOV ASCIIN[DI], AL
	INC DI
	JMP BUCLE 
FINISH: ;COLOCA UN $ AL FINAL DE LA CADENA Y EL SIGNO AL PRINCIPIO
	MOV AH, SIGNO
	MOV ASCIIN, AH 
	MOV ASCIIN[DI], '$'
	RET
CONVERTASC ENDP

PRINTNUM PROC FAR ;SE IMPRIME EL NUMERO DEL DETERMINANTE CORRESPONDIENTE
	ADD MATRIZ[BX], 0
	JNS POSITIVO
	MOV SIGNO, '-'
	NEG MATRIZ[BX] ; HACEMOS QUE EL NÚMERO GUARDADO EN MATRIZ SEA POSITIVO
	JMP CONT
POSITIVO: 
	MOV SIGNO, '+'
CONT: 
	CALL CONVERTN	;CONVERTIMOS EL NUMERO EN UNA CADENA FORMADA POR SUS DIGITOS
	CALL CONVERTASC ;CONVERTIMOS LA CADENA A LO QUE HAY QUE IMPRIMIR EN ASCII
	MOV AH, WRITE
	MOV DX, OFFSET ASCIIN ; IMPRIMIMOS EL NÚMERO
	INT 21H
	RET
PRINTNUM ENDP

PRINTRES PROC FAR ;IMPRIME EL RESULTADO DEL DETERMINANTE
	ADD RESULT, 0     ;NECESITAMOS UNA FUNCIÓN DIFERENTE A LA DE LOS DIGITOS YA QUE EL RESULTADO ES UNA PALABRA
	JNS POSITIVO1
	MOV SIGNO, '-'
	NEG RESULT
	JMP CONT1
POSITIVO1: 
	MOV SIGNO, '+'
CONT1:	;EL PROCESO DE CONVERSION ES EL MISMO QUE CON LOS NUMEROS NORMALES
	CALL CONVERTRES
	CALL CONVERTASC
	MOV AH, WRITE
	MOV DX, OFFSET ASCIIN ; IMPRIMIMOS EL NÚMERO
	INT 21H
	RET 
PRINTRES ENDP

CONVERTRES PROC FAR ;SEPARA LOS DIGITOS DEL RESULTADO EN POSICIONES DISTINTAS 
	MOV SI, 0
	MOV AX, RESULT
	MOV CX, 10 ; TENEMOS QUE DIVIDIR POR 10
DIVID1:	;REALIZAMOS EL ALGORITMO DE DIVISION PARA SEPARAR EN DIGITOS EL NUMERO
	MOV DX, 0
	DIV CX
	MOV DECIMN[SI], DL ; GUARDAMOS EN DECIMN EL RESTO DE LA DIVISIÓN 
	INC SI ; INCREMENTAMOS LA POSICIÓN EN LA QUE GUARDAREMOS LA SIGUIENTE POSIBLE CIFRA
	ADD AX, 0
	JNZ DIVID1 ; SI EL COCIENTE NO ES CERO, SEGUIMOS DIVIDIENDO
	RET
CONVERTRES ENDP

ASCTON PROC FAR ; PARSEA CARÁCTERES ASCII QUE REPRESENTAN UN NÚMERO A DICHO NÚMERO
	MOV AL, MATRIZASC[BX]
	MOV SIGNO, AL ; GUARDAMOS EL SIGNO DEL NÚMERO
	INC BX
	MOV AX, 0 ; VACIAMOS AX
	MOV DH, 10 ; TENEMOS QUE MULTIPLICAR POR 10
CONT2:
	CMP MATRIZASC[BX], NL ; MIRAMOS SI HA ACABADO LA CADENA INTRODUCIDA POR EL USUARIO
	JE COMPR
	MOV DL, MATRIZASC[BX]
	SUB DL, TOASC ; CONVERTIMOS UNA CIFRA EN ASCII EN EL NÚMERO QUE REPRESENTA
	MUL DH ; MULTIPLICAMOS POR 10 LAS CIFRAS ANTERIORES
	JO ERROR1 ; SI HAY OVERFLOW
	ADD AL, DL ; AÑADIMOS EL RESULTADO AL TOTAL
	INC BX
	CMP MATRIZASC[BX], ',' ; MIRAMOS SI HEMOS ACABADO CON EL NÚMERO
	JNE CONT2
	CMP SIGNO, '-' ; SI EL NÚMERO ERA NEGATIVO, LE TENEMOS QUE HACER NEG
	JNE COMPR
	NEG AL
	JMP COMPR
ERROR1:	;ERROR SI HAY OVERFLOW
	MOV ERRFLAG, 1
	JMP FINAL3
COMPR:	;ERROR SI EL NÚMERO ES MAYOR QUE 15 O MENOR QUE -16
	CMP AL, LIMINF
	JL ERROR1
	CMP AL, LIMSUP
	JG ERROR1
FINAL3:
	MOV MATRIZ[SI], AL ; GUARDAMOS EL NÚMERO EN MATRIZ
	RET
ASCTON ENDP

; FIN DEL SEGMENTO DE CODIGO
CODE ENDS
; FIN DEL PROGRAMA INDICANDO DONDE COMIENZA LA EJECUCION
END INICIO 
