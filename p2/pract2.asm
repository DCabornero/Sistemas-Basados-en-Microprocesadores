;**************************************************************************
; SBM 2019
; PRACTICA 2
; AUTORES: David Cabornero Pascual y Sergio Galán Martín
;**************************************************************************
; DEFINICION DEL SEGMENTO DE DATOS
DATOS SEGMENT
CLR_PANT DB 1BH, "[2", "J$"
MATRIZ DB 9, 8, 7, 6, 5, 4, 3, 2, -4 
RESULT DW 0
ACCESOS DW 0, 4, 8, 3, 7, 2, 1, 5, 6, 2, 4, 6, 3, 1, 8, 0, 7, 5
SIGNO DB ?
TAB DB 9, '$'
SLASH DB 7CH, '$'
NEWLINE DB 0AH, '$'
SPACE DB " $"
DETA DB "   |A|= |$"
EQB DB "| = $"
DECIMN DB 2 dup(?)
ASCIIN DB 4 dup(?)
DATOS ENDS
;**************************************************************************
; DEFINICION DEL SEGMENTO DE PILA
PILA SEGMENT STACK "STACK"
DB 40H DUP (0) ;ejemplo de inicialización, 64 bytes inicializados a 0
PILA ENDS
;**************************************************************************
; DEFINICION DEL SEGMENTO EXTRA
EXTRA SEGMENT
EXTRA ENDS
;**************************************************************************
; DEFINICION DEL SEGMENTO DE CODIGO
CODE SEGMENT
ASSUME CS: CODE, DS: DATOS, ES: EXTRA, SS: PILA
; COMIENZO DEL PROCEDIMIENTO PRINCIPAL
INICIO PROC
; INICIALIZA LOS REGISTROS DE SEGMENTO CON SU VALOR
MOV AX, DATOS
MOV DS, AX
MOV AX, PILA
MOV SS, AX
MOV AX, EXTRA
MOV ES, AX
MOV SP, 64 ; CARGA EL PUNTERO DE PILA CON EL VALOR MAS ALTO
; FIN DE LAS INICIALIZACIONES
; COMIENZO DEL PROGRAMA
MOV BX, 0
CALL DIAG
ADD RESULT, AX
ADD BX, 6
CALL DIAG
ADD RESULT, AX
ADD BX, 6
CALL DIAG
ADD RESULT, AX
ADD BX, 6
CALL DIAG
SUB RESULT, AX
ADD BX, 6
CALL DIAG
SUB RESULT, AX
ADD BX, 6
CALL DIAG
SUB RESULT, AX

CALL OUTPUT


; FIN DEL PROGRAMA
MOV AX, 4C00H
INT 21H
INICIO ENDP

DIAG PROC FAR ;GUARDA EN AX LA DIAGONAL CALCULADA
MOV SI, ACCESOS[BX]
MOV AL, MATRIZ[SI]
MOV SI, ACCESOS[BX+2]
MOV DL, MATRIZ[SI]
IMUL DL
MOV SI, ACCESOS[BX+4]
MOV DL, MATRIZ[SI]
MOV DH, 0
IMUL DX
RET
DIAG ENDP



OUTPUT PROC FAR ;IMPRIME POR PANTALLA LA SALIDA DESEADA
MOV BX, 0
MOV AH, 9 ; BORRA LA PANTALLA
MOV DX, OFFSET CLR_PANT
INT 21H

MOV DX, OFFSET TAB ;IMPRIME LOS TABULADORES
INT 21H

MOV DX, OFFSET SLASH ;COMIENZA LA PRIMERA FILA DEL DETERMINANTE
INT 21H

CALL PRINTNUM ;IMPRIME LOS TRES PRIMEROS NUMEROS DEL DETERMINANTE
INC BX
MOV DX, OFFSET SPACE
INT 21H
CALL PRINTNUM
INC BX
MOV DX, OFFSET SPACE
INT 21H
CALL PRINTNUM
INC BX


;MOV AH, 9
MOV DX, OFFSET SLASH ;CIERRA LA PRIMERA FILA DEL DETERMINANTE
INT 21H

MOV DX, OFFSET NEWLINE ;SALTO DE LINEA
INT 21H

MOV DX, OFFSET DETA ; |A| = |
INT 21H

CALL PRINTNUM ;ESCRIBE LA SEGUNDA FILA DEL DETERMINANTE
INC BX
MOV DX, OFFSET SPACE
INT 21H
CALL PRINTNUM
MOV DX, OFFSET SPACE
INT 21H
INC BX
CALL PRINTNUM
INC BX

;MOV AH, 9
MOV DX, OFFSET EQB ;CIERRA LA SEGUNDA FILA E IMPRIME UN IGUAL
INT 21H

CALL PRINTRES ;IMPRIME EL RESULTADO

MOV DX, OFFSET NEWLINE ;SALTO DE LINEA
INT 21H

MOV DX, OFFSET TAB ;IMPRIME LOS TABULADORES
INT 21H

MOV DX, OFFSET SLASH ;COMIENZA LA TERCERA FILA DEL DETERMINANTE
INT 21H

CALL PRINTNUM ;IMPRIME LA TERCERA FILA DEL DETERMINANTE
INC BX
MOV DX, OFFSET SPACE
INT 21H
CALL PRINTNUM
INC BX
MOV DX, OFFSET SPACE
INT 21H
CALL PRINTNUM
INC BX

;MOV AH, 9
MOV DX, OFFSET SLASH ;CIERRA LA TERCERA FILA DEL DETERMINANTE
INT 21H

RET
OUTPUT ENDP



CONVERTN PROC FAR ;SE COLOCA CADA DIGITO DECIMAL DEL NUMERO EN UNA POSICION DISTINTA
MOV SI, 0
MOV AL, MATRIZ[BX]
MOV CL, 0AH
DIVID:
MOV AH, 0H
DIV CL
MOV DECIMN[SI], AH ; GUARDAMOS EN DECIMN EL RESTO DE LA DIVISIÓN 
INC SI ; INCREMENTAMOS LA POSICIÓN EN LA QUE GUARDAREMOS LA SIGUIENTE POSIBLE CIFRA
ADD AL, 0
JNZ DIVID ; SI EL COCIENTE NO ES CERO, SEGUIMOS DIVIDIENDO
RET
CONVERTN ENDP



CONVERTASC PROC FAR ;CONVIERTE LOS NUMEROS SEPARADOS EN ASCII PARA IMPRIMIRLOS
MOV DI, 1
BUCLE: DEC SI ;SUMAMOS 30 A LOS NUMEROS PARA QUE COINCIDAN CON SU CODIGO ASCII
JS FINISH
MOV AL, DECIMN[SI]
ADD AL, 30H
MOV ASCIIN[DI], AL
INC DI
JMP BUCLE 
FINISH: ;COLOCA UN $ AL FINAL DE LA CADENA Y EL SIGNO AL PRINCIPIO
MOV AH, SIGNO
MOV ASCIIN, AH 
MOV ASCIIN[DI], '$'
RET
CONVERTASC ENDP



PRINTNUM PROC FAR ;SE IMPRIME EL NUMERO DEL DETERMINANTE CORRESPONDIENTE
ADD MATRIZ[BX], 0
JNS POSITIVO
MOV SIGNO, '-'
NEG MATRIZ[BX] ; HACEMOS QUE EL NÚMERO GUARDADO EN MATRIZ SEA POSITIVO
JMP CONT
POSITIVO: MOV SIGNO, '+'
CONT: 
CALL CONVERTN	;CONVERTIMOS EL NUMERO EN UNA CADENA FORMADA POR SUS DIGITOS
CALL CONVERTASC ;CONVERTIMOS LA CADENA A LO QUE HAY QUE IMPRIMIR EN ASCII
MOV AH, 9
MOV DX, OFFSET ASCIIN ; IMPRIMIMOS EL NÚMERO
INT 21H
RET
PRINTNUM ENDP



PRINTRES PROC FAR ;IMPRIME EL RESULTADO DEL DETERMINANTE
ADD RESULT, 0
JNS POSITIVO1
MOV SIGNO, '-'
NEG RESULT
JMP CONT1
POSITIVO1: MOV SIGNO, '+'
CONT1:	;EL PROCESO DE CONVERSION ES EL MISMO QUE CON LOS NUMEROS NORMALES
CALL CONVERTRES
CALL CONVERTASC
MOV DX, OFFSET ASCIIN ; IMPRIMIMOS EL NÚMERO
INT 21H
RET 
PRINTRES ENDP



CONVERTRES PROC FAR ;SEPARA LOS DIGITOS DEL RESULTADO EN POSICIONES DISTINTAS 
MOV SI, 0
MOV AX, RESULT
MOV CX, 0AH
DIVID1:	;REALIZAMOS EL ALGORITMO DE DIVISION PARA SEPARAR EN DIGITOS EL NUMERO
DIV CX
MOV DECIMN[SI], DL ; GUARDAMOS EN DECIMN EL RESTO DE LA DIVISIÓN 
INC SI ; INCREMENTAMOS LA POSICIÓN EN LA QUE GUARDAREMOS LA SIGUIENTE POSIBLE CIFRA
ADD AX, 0
JNZ DIVID1 ; SI EL COCIENTE NO ES CERO, SEGUIMOS DIVIDIENDO
RET
CONVERTRES ENDP



; FIN DEL SEGMENTO DE CODIGO
CODE ENDS
; FIN DEL PROGRAMA INDICANDO DONDE COMIENZA LA EJECUCION
END INICIO 
